---
title: "Autogenous - Selection Scan with pcadapt"
author: "Luciano V Cosme"
date: "`r Sys.Date()`"
output:
  html_document:
    highlight: breezedark
    css:
      - "styles.css"
    toc: yes
    toc_float: no
    toc_depth: 5
editor_options:
  markdown:
    wrap: 120
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  eval                        = TRUE,
  echo                        = TRUE,
  cache                       = TRUE, # tidy = TRUE,
  class.output                = "bg-success"
)
knitr::opts_knit$set(
  root.dir = rprojroot::find_rstudio_root_file()
)
```



## 1. R libraries and software

```{r libraries, message=FALSE, results='hide', warning=FALSE}
library(tidyverse)
library(colorout)
library(here)
library(ggplot2)
library(scales)
library(reticulate)
library(qvalue)
library(flextable)
library(officer)
library(ggvenn)
library(extrafont)
library(forcats)
library(ggrepel)
library(ggtext)
library(R.SamBada)
library(rgdal)
library(stats)
library(geosphere)
library(pcadapt)
```

## 2. pcadapt with all 3 populations (MAN, NEW and AUT)

pcadapt performs principal component analysis and computes p-values to test for outliers. The test for outliers is based on the correlations between genetic variation and the first K principal components. pcadapt also handles Pool-seq data for which the statistical analysis is performed on the genetic markers frequencies. Returns an object of class pcadapt.


```{r}
# read the file
x <- read.pcadapt(here("output", "outflank","autogenous.bed"), type = "bed")
```


```{r, warning=FALSE}
# Run pcadapt with a large number of PCs
pcadapt_res <- pcadapt(x, K = 30)

# Create a scree plot
plot(pcadapt_res, option = "screeplot")
```

Choose PCs
```{r}
# perform the analysis
pcadapt_res <- pcadapt(
  x, 
  method = c("mahalanobis"),
  min.maf = 0.1,
  LD.clumping = NULL,
  tol = 1e-04,
  K = 2) # choose the right K for your data

str(pcadapt_res)
```



```{r}
#   ____________________________________________________________________________
#   import the bim file with the SNP data                                   ####
snps <-
  read_delim(                    # to learn about the options use here, run ?read_delim on the console.
    here(
      "output", "outflank", "autogenous.bim"
    ),                           # use library here to load it
    col_names      = FALSE,      # we don't have header in the input file
    show_col_types = FALSE,      # suppress message from read_delim
    col_types      = "ccidcc"    # set the class of each column
  )
#
# set column names
colnames(
  snps
) <-                             # to add a header in our tibble
  c(
    "Scaffold", "SNP", "Cm", "Position", "Allele1", "Allele2"
  )
#
# check the tibble
head(snps)
```

```{r}
# Combine into a data frame
pcadapt_res_df <- data.frame(
  SNP = snps$SNP,
  Chromosome = snps$Scaffold,
  Position = snps$Position,
  pvalues = pcadapt_res$pvalues,
  stat = pcadapt_res$stat
) |> drop_na()
head(pcadapt_res_df)
```


Adjust
```{r}
# Adjust the p-values using Benjamini-Hochberg method
padj <- p.adjust(pcadapt_res_df$pvalues,method="BH")

# Define significance level
alpha <- 0.05

# Get indices of significant SNPs
outliers_indices <- which(padj < alpha)

# Get the SNP IDs of the outliers
outlier_snps <- pcadapt_res_df$SNP[outliers_indices]

# Print the SNP IDs
length(outlier_snps)

# Save it
write.table(
  outlier_snps,
  file = here("output", "pcadapt","SNPs_pcadapt.txt"),
  row.names = FALSE,
  quote = FALSE,
  col.names = FALSE,
  sep = "\n"
)
```


```{r}
# Set colors for the chromosomes
color_vector <- c("#CCF6D6", "#F6E1CC", "#CCD8F6")  # Add or remove colors as needed.
names(color_vector) <- unique(pcadapt_res_df$Chromosome)  # Make sure unique(df_sub$Chromosome) gives all unique Chromosome values.

# Adjust the p-values using Benjamini-Hochberg method
padj <- p.adjust(pcadapt_res_df$pvalues,method="BH")

# Define significance level
alpha <- 0.05

# Get indices of significant SNPs
outliers_indices <- which(padj < alpha)

# Create a new 'highlight' column, initially set to FALSE
pcadapt_res_df$highlight <- FALSE

# Update the 'highlight' column to highlight these outlier SNPs
pcadapt_res_df$highlight[outliers_indices] <- TRUE

# Identify the SNP with the smallest p-value in each chromosome among the associated SNPs
min_pval_snps <- pcadapt_res_df |>
  filter(highlight) |>
  group_by(Chromosome) |>
  slice(which.min(pvalues))

# Custom label function
k_format <- function(x) {
  paste0(format(x / 1e6, big.mark = "", scientific = FALSE), "k")
}

# source the plotting function
source(
  here(
    "scripts", "analysis", "my_theme2.R"
  )
)

# Create the plot
ggplot(pcadapt_res_df, aes(x = Position, y = -log10(pvalues))) +
  geom_point(aes(color = Chromosome),
             data = subset(pcadapt_res_df, highlight == FALSE),
             size = .5) +
  geom_point(
    color = "magenta",
    data = subset(pcadapt_res_df, highlight == TRUE),
    size = .5
  ) +
  scale_color_manual(values = color_vector, guide = "none") +
  labs(title = "pcadapt Brazil", x = "Position", y = "-log10(p-value)", caption = "SNPs highlighted in magenta are significant after Benjamini-Hochberg adjustment (p<0.05).") +
  facet_wrap(~ Chromosome, scales = "free_x") +
  scale_x_continuous(labels = k_format) +
  my_theme() +
  theme(panel.spacing = unit(.2, "lines"),
        plot.margin = unit(c(1, 1, 2, 2), "lines"),
        plot.caption = element_markdown(face = "italic", color = "#574E4E")) +
  # Annotate only the SNP with the smallest p-value for each chromosome among the associated SNPs
  geom_text_repel(
    data = min_pval_snps,
    aes(label = SNP),
    size = 3,
    nudge_y = 0.01,
    segment.color = NA,
    max.overlaps = Inf # Set to 'Inf' to show all annotations
  )

# Save the plot
ggsave(
  here(
    "output", "pcadapt", "figures", "pcadapt.pdf"
  ),
  width  = 8,
  height = 5,
  units  = "in"
)
```

```{r}
plot(pcadapt_res, option = "qqplot")
```


```{r}
plot(pcadapt_res, option = "scores")
```

```{r}
hist(pcadapt_res$pvalues, xlab = "p-values", main = NULL, breaks = 50, col = "pink")
```


```{r, warning=FALSE}
plot(pcadapt_res, option = "stat.distribution")
```

Choosing a cutoff for outlier detection

q-values
```{r}
qval <- qvalue(pcadapt_res$pvalues)$qvalues
alpha <- 0.05
outliers <- which(qval < alpha)
length(outliers)
```

Benjamini-Hochberg Procedure
```{r}
padj <- p.adjust(pcadapt_res$pvalues,method="BH")
alpha <- 0.05
outliers <- which(padj < alpha)
length(outliers)
```

Bonferroni correction

```{r}
padj <- p.adjust(pcadapt_res$pvalues,method="bonferroni")
alpha <- 0.05
outliers <- which(padj < alpha)
length(outliers)
```

Loadings

```{r}
par(mfrow = c(2, 2))
for (i in 1:2)
  plot(pcadapt_res$loadings[, i], pch = 19, cex = .3, ylab = paste0("Loadings PC", i))
```


### 2.1 Venn diagram outFlank vs pcadapt

```{r}
# Read data from txt files
outflank_snps <-
  read.table(
    here("output", "outflank", "SNPs_outFlank.txt"),
    stringsAsFactors = FALSE
  ) |>
  drop_na()
pcadapt_snps <-
  read.table(
    here("output", "pcadapt", "SNPs_pcadapt.txt"),
    stringsAsFactors = FALSE
  )

# Create a list with all dataframes
list_of_clusters <- list("outFlank" = outflank_snps$V1, "pcadapt" = pcadapt_snps$V1)


# Create Venn diagram
venn_diagram <- ggvenn(list_of_clusters, fill_color = c("steelblue", "darkorange"))
print(venn_diagram)

# Find common SNPs
common_SNPs <- Reduce(intersect, list_of_clusters)

# Save the shared SNP ids into a txt file
write.table(
  common_SNPs,
  file = here("output", "pcadapt", "common_SNPs_pcadapt_outflank.txt"),
  row.names = FALSE,
  col.names = FALSE,
  quote = FALSE
)

# # Save Venn diagram to PDF
output_path <- here("output", "pcadapt", "figures", "significant_snps.pdf")
ggsave(output_path, venn_diagram, height = 5, width = 5, dpi = 300)
```
With python
Clean env
```{r}
py_run_string("import gc; gc.collect()")
```

Venn
```{python}
import pandas as pd
from matplotlib_venn import venn2
import matplotlib.pyplot as plt
import gc

# File paths
path_outflank = 'output/outflank/SNPs_outFlank.txt'
path_pcadapt = 'output/pcadapt/SNPs_pcadapt.txt'
pdf_output_path = 'output/pcadapt/venn_3_pop_pcadapt_outflank.pdf'  # PDF output file path

# Read the data (assuming the SNP IDs are in the first column)
outflank_snps = pd.read_csv(path_outflank, sep="\t", header=None)
pcadapt_snps = pd.read_csv(path_pcadapt, sep="\t", header=None)

# Drop NA values if any
outflank_snps.dropna(inplace=True)
pcadapt_snps.dropna(inplace=True)

# Create sets from the first column of each dataframe
set_outflank = set(outflank_snps[0])
set_pcadapt = set(pcadapt_snps[0])

# Create a Venn diagram
venn2([set_outflank, set_pcadapt], ('outFlank', 'pcadapt'), set_colors=('blue', 'gray'))

# Save the plot in PDF format
plt.savefig(pdf_output_path, format='pdf')

# Show the plot
plt.show()

# Clearing the environment
del path_outflank, path_pcadapt, pdf_output_path, outflank_snps, pcadapt_snps, set_outflank, set_pcadapt
plt.clf()  # Clear the current figure
plt.cla()  # Clear the current axes

# Garbage collection
gc.collect()
```

Create plot with the shared SNPs
```{r, fig.width=8, fig.height=5}
# Filter the dataframe
filtered_df <- pcadapt_res_df |> filter(SNP %in% common_SNPs)

# Create the plot
ggplot(pcadapt_res_df, aes(x = Position, y = -log10(pvalues))) +
  geom_point(
    aes(color = Chromosome),
    data = subset(pcadapt_res_df, highlight == FALSE),
    size = .3
  ) +
  geom_point(
    color = "magenta",
    data = subset(filtered_df, highlight == TRUE),
    size = .3
  ) +
  scale_color_manual(values = color_vector, guide = "none") +
  labs(x = "Position", y = "-log10(p-value)", caption = "SNPs highlighted in magenta are significant after \n Benjamini-Hochberg adjustment (p<0.001) with pcadapt, \nand were identified as outliers with outFlank") +
  facet_wrap( ~ Chromosome, scales = "free_x") +
  scale_x_continuous(labels = k_format) +
  my_theme() +
  theme(
    panel.spacing = unit(.2, "lines"),
    plot.margin = unit(c(1, 1, 2, 2), "lines"),
    plot.caption = element_text(face = "italic")
  ) +
  # Annotate only the SNP with the smallest p-value for each chromosome among the associated SNPs
  geom_text_repel(
    data = min_pval_snps,
    aes(label = SNP),
    size = 3,
    nudge_y = 0.01,
    segment.color = NA,
    max.overlaps = Inf # Set to 'Inf' to show all annotations
  )
```

```{r}
# Save the plot
ggsave(
  here(
    "output", "pcadapt", "figures", "pcadapt_outflank.pdf"
  ),
  width  = 8,
  height = 5,
  units  = "in"
)
```


We can create windows and count how many highlighted SNPs we have in each window. Then we can focus in genomic areas with several SNPs
```{r, fig.width=8, fig.height=5}
cluster_df <- filtered_df %>%
  mutate(Window_Start = floor(Position / 10000000) * 10000000) %>%
  group_by(Chromosome, Window_Start) %>%
  summarise(SNP_count = n(), .groups = 'drop')

# Create the plot
ggplot(pcadapt_res_df, aes(x = Position, y = -log10(pvalues))) +
  geom_point(
    aes(color = Chromosome),
    data = subset(pcadapt_res_df, highlight == FALSE),
    size = .3
  ) +
  geom_point(
    color = "magenta",
    data = subset(filtered_df, highlight == TRUE),
    size = .3
  ) +
  geom_vline(
    data = cluster_df,
    aes(xintercept = Window_Start + 5000000),
    color = "lightgray",
    linetype = "dashed",
    linewidth = 0.5
  ) +
  geom_text_repel(
    data = cluster_df,
    aes(x = Window_Start + 5000000, y = 15, label = SNP_count),
    vjust = -1,
    hjust = -0.5
  ) +
  scale_color_manual(values = color_vector, guide = "none") +
  labs(x = "Position", y = "-log10(p-value)", caption = "SNPs highlighted in magenta are significant after \n Benjamini-Hochberg adjustment (p<0.001) with pcadapt, \nand were identified as outliers with outFlank \n Gray bars represent 10Mb windows and \n the number of SNPs per window is annotated in black.") +
  facet_wrap( ~ Chromosome, scales = "free_x") +
  scale_x_continuous(labels = k_format) +
  my_theme() +
  theme(
    panel.spacing = unit(.2, "lines"),
    plot.margin = unit(c(1, 1, 2, 2), "lines"),
    plot.caption = element_text(face = "italic"),
    legend.position = "none" # Remove legend
  ) +
  geom_text_repel(
    data = min_pval_snps,
    aes(label = SNP),
    size = 3,
    nudge_y = 0.01,
    segment.color = NA,
    max.overlaps = Inf # Set to 'Inf' to show all annotations
  )


```

Check the SNP ids for each cluster
```{r}
# Create a new dataframe to capture SNPs within each 100kb window for each chromosome
cluster_snps_df <- filtered_df %>%
  mutate(Window_Start = floor(Position / 10000000) * 10000000) %>%
  group_by(Chromosome, Window_Start) %>%
  summarise(SNPs = list(SNP), .groups = 'drop')

# Unnest the SNPs column to show each SNP on its own row
unnested_cluster_snps_df <- cluster_snps_df %>% 
  unnest(SNPs)

# View the unnested data
head(unnested_cluster_snps_df)
```

```{r}
# Convert the list column to a string column
cluster_snps_df_str <- cluster_snps_df %>%
  mutate(SNPs = sapply(SNPs, function(x) paste(x, collapse = ", ")))

# Create the flextable
my_flextable <- flextable(cluster_snps_df_str, cwidth = 2.75)

my_flextable <- autofit(my_flextable)

# Display the flextable
my_flextable

# Initialize a Word document
doc <- read_docx()

# Add flextable to Word document
doc <- body_add_flextable(doc, value = my_flextable)

# Save the Word document
print(doc, target = here("output", "pcadapt", "snps_pcadap_outflank.docx"))
```








## 3. pcadapt with all 2 populations (MAN and AUT)

pcadapt performs principal component analysis and computes p-values to test for outliers. The test for outliers is based on the correlations between genetic variation and the first K principal components. pcadapt also handles Pool-seq data for which the statistical analysis is performed on the genetic markers frequencies. Returns an object of class pcadapt.

Clean env and memory
```{r}
# Remove all objects from the environment
rm(list = ls())

# Run the garbage collector to free up memory
gc()
```


```{r}
# read the file
x <- read.pcadapt(here("output", "outflank","man_aut.bed"), type = "bed")
```


```{r, warning=FALSE}
# Run pcadapt with a large number of PCs
pcadapt_res <- pcadapt(x, K = 30)

# Create a scree plot
plot(pcadapt_res, option = "screeplot")
```

Choose PCs
```{r}
# perform the analysis
pcadapt_res <- pcadapt(
  x, 
  method = c("mahalanobis"),
  min.maf = 0.1,
  LD.clumping = NULL,
  tol = 1e-04,
  K = 2) # choose the right K for your data

str(pcadapt_res)
```



```{r}
#   ____________________________________________________________________________
#   import the bim file with the SNP data                                   ####
snps <-
  read_delim(                    # to learn about the options use here, run ?read_delim on the console.
    here(
      "output", "outflank", "man_aut.bim"
    ),                           # use library here to load it
    col_names      = FALSE,      # we don't have header in the input file
    show_col_types = FALSE,      # suppress message from read_delim
    col_types      = "ccidcc"    # set the class of each column
  )
#
# set column names
colnames(
  snps
) <-                             # to add a header in our tibble
  c(
    "Scaffold", "SNP", "Cm", "Position", "Allele1", "Allele2"
  )
#
# check the tibble
head(snps)
```

```{r}
# Combine into a data frame
pcadapt_res_df <- data.frame(
  SNP = snps$SNP,
  Chromosome = snps$Scaffold,
  Position = snps$Position,
  pvalues = pcadapt_res$pvalues,
  stat = pcadapt_res$stat
) |> drop_na()
head(pcadapt_res_df)
```


Adjust
```{r}
# Adjust the p-values using Benjamini-Hochberg method
padj <- p.adjust(pcadapt_res_df$pvalues,method="BH")

# Define significance level
alpha <- 0.05

# Get indices of significant SNPs
outliers_indices <- which(padj < alpha)

# Get the SNP IDs of the outliers
outlier_snps <- pcadapt_res_df$SNP[outliers_indices]

# Print the SNP IDs
length(outlier_snps)

# Save it
write.table(
  outlier_snps,
  file = here("output", "pcadapt","man_aut_SNPs_pcadapt.txt"),
  row.names = FALSE,
  quote = FALSE,
  col.names = FALSE,
  sep = "\n"
)
```


```{r}
# Set colors for the chromosomes
color_vector <- c("#CCF6D6", "#F6E1CC", "#CCD8F6")  # Add or remove colors as needed.
names(color_vector) <- unique(pcadapt_res_df$Chromosome)  # Make sure unique(df_sub$Chromosome) gives all unique Chromosome values.

# Adjust the p-values using Benjamini-Hochberg method
padj <- p.adjust(pcadapt_res_df$pvalues,method="BH")

# Define significance level
alpha <- 0.05

# Get indices of significant SNPs
outliers_indices <- which(padj < alpha)

# Create a new 'highlight' column, initially set to FALSE
pcadapt_res_df$highlight <- FALSE

# Update the 'highlight' column to highlight these outlier SNPs
pcadapt_res_df$highlight[outliers_indices] <- TRUE

# Identify the SNP with the smallest p-value in each chromosome among the associated SNPs
min_pval_snps <- pcadapt_res_df |>
  filter(highlight) |>
  group_by(Chromosome) |>
  slice(which.min(pvalues))

# Custom label function
k_format <- function(x) {
  paste0(format(x / 1e6, big.mark = "", scientific = FALSE), "k")
}

# source the plotting function
source(
  here(
    "scripts", "analysis", "my_theme2.R"
  )
)

# Create the plot
ggplot(pcadapt_res_df, aes(x = Position, y = -log10(pvalues))) +
  geom_point(aes(color = Chromosome),
             data = subset(pcadapt_res_df, highlight == FALSE),
             size = .5) +
  geom_point(
    color = "magenta",
    data = subset(pcadapt_res_df, highlight == TRUE),
    size = .5
  ) +
  scale_color_manual(values = color_vector, guide = "none") +
  labs(title = "pcadapt Brazil", x = "Position", y = "-log10(p-value)", caption = "SNPs highlighted in magenta are significant after Benjamini-Hochberg adjustment (p<0.05).") +
  facet_wrap(~ Chromosome, scales = "free_x") +
  scale_x_continuous(labels = k_format) +
  my_theme() +
  theme(panel.spacing = unit(.2, "lines"),
        plot.margin = unit(c(1, 1, 2, 2), "lines"),
        plot.caption = element_markdown(face = "italic", color = "#574E4E")) +
  # Annotate only the SNP with the smallest p-value for each chromosome among the associated SNPs
  geom_text_repel(
    data = min_pval_snps,
    aes(label = SNP),
    size = 3,
    nudge_y = 0.01,
    segment.color = NA,
    max.overlaps = Inf # Set to 'Inf' to show all annotations
  )

# Save the plot
ggsave(
  here(
    "output", "pcadapt", "figures", "man_aut_pcadapt.pdf"
  ),
  width  = 8,
  height = 5,
  units  = "in"
)
```

```{r}
plot(pcadapt_res, option = "qqplot")
```


```{r}
plot(pcadapt_res, option = "scores")
```

```{r}
hist(pcadapt_res$pvalues, xlab = "p-values", main = NULL, breaks = 50, col = "pink")
```


```{r, warning=FALSE}
plot(pcadapt_res, option = "stat.distribution")
```

Choosing a cutoff for outlier detection

q-values
```{r}
qval <- qvalue(pcadapt_res$pvalues)$qvalues
alpha <- 0.05
outliers <- which(qval < alpha)
length(outliers)
```

Benjamini-Hochberg Procedure
```{r}
padj <- p.adjust(pcadapt_res$pvalues,method="BH")
alpha <- 0.05
outliers <- which(padj < alpha)
length(outliers)
```

Bonferroni correction

```{r}
padj <- p.adjust(pcadapt_res$pvalues,method="bonferroni")
alpha <- 0.05
outliers <- which(padj < alpha)
length(outliers)
```

Loadings

```{r}
par(mfrow = c(2, 2))
for (i in 1:2)
  plot(pcadapt_res$loadings[, i], pch = 19, cex = .3, ylab = paste0("Loadings PC", i))
```


### 3.1 Venn diagram outFlank vs pcadapt

```{r}
# Read data from txt files
outflank_snps <-
  read.table(
    here("output", "outflank", "man_aut_SNPs_outFlank.txt"),
    stringsAsFactors = FALSE
  ) |>
  drop_na()

pcadapt_snps <-
  read.table(
    here("output", "pcadapt", "man_aut_SNPs_pcadapt.txt"),
    stringsAsFactors = FALSE
  )

# Create a list with all dataframes
list_of_clusters <- list("outFlank" = outflank_snps$V1, "pcadapt" = pcadapt_snps$V1)


# Create Venn diagram
venn_diagram <- ggvenn(list_of_clusters, fill_color = c("steelblue", "darkorange"))
print(venn_diagram)

# Find common SNPs
common_SNPs <- Reduce(intersect, list_of_clusters)

# Save the shared SNP ids into a txt file
write.table(
  common_SNPs,
  file = here("output", "pcadapt", "man_aut_common_SNPs_pcadapt_outflank.txt"),
  row.names = FALSE,
  col.names = FALSE,
  quote = FALSE
)

# # Save Venn diagram to PDF
output_path <- here("output", "pcadapt", "figures", "man_aut_significant_snps.pdf")
ggsave(output_path, venn_diagram, height = 5, width = 5, dpi = 300)
```
With python

Clean env
```{r}
py_run_string("import gc; gc.collect()")
```

Venn
```{python}
import pandas as pd
from matplotlib_venn import venn2
import matplotlib.pyplot as plt

# File paths
path_outflank = 'output/outflank/man_aut_SNPs_outFlank.txt'
path_pcadapt = 'output/pcadapt/man_aut_SNPs_pcadapt.txt'
pdf_output_path = 'output/pcadapt/venn_MAN_AUT_pcadapt_outflank.pdf'  # PDF output file path

# Read the data (assuming the SNP IDs are in the first column)
outflank_snps = pd.read_csv(path_outflank, sep="\t", header=None)
pcadapt_snps = pd.read_csv(path_pcadapt, sep="\t", header=None)

# Drop NA values if any
outflank_snps.dropna(inplace=True)
pcadapt_snps.dropna(inplace=True)

# Create sets from the first column of each dataframe
set_outflank = set(outflank_snps[0])
set_pcadapt = set(pcadapt_snps[0])

# Create a Venn diagram
venn2([set_outflank, set_pcadapt], ('outFlank', 'pcadapt'), set_colors=('yellow', 'gray'))

# Save the plot in PDF format
plt.savefig(pdf_output_path, format='pdf')

# Show the plot
plt.show()

# Clearing the environment
del path_outflank, path_pcadapt, pdf_output_path, outflank_snps, pcadapt_snps, set_outflank, set_pcadapt
plt.clf()  # Clear the current figure
plt.cla()  # Clear the current axes

# Garbage collection
gc.collect()
```


Create plot with the shared SNPs
```{r, fig.width=8, fig.height=5}
# Filter the dataframe
filtered_df <- pcadapt_res_df |> filter(SNP %in% common_SNPs)

# Create the plot
ggplot(pcadapt_res_df, aes(x = Position, y = -log10(pvalues))) +
  geom_point(
    aes(color = Chromosome),
    data = subset(pcadapt_res_df, highlight == FALSE),
    size = .3
  ) +
  geom_point(
    color = "magenta",
    data = subset(filtered_df, highlight == TRUE),
    size = .3
  ) +
  scale_color_manual(values = color_vector, guide = "none") +
  labs(x = "Position", y = "-log10(p-value)", caption = "SNPs highlighted in magenta are significant after \n Benjamini-Hochberg adjustment (p<0.001) with pcadapt, \nand were identified as outliers with outFlank") +
  facet_wrap( ~ Chromosome, scales = "free_x") +
  scale_x_continuous(labels = k_format) +
  my_theme() +
  theme(
    panel.spacing = unit(.2, "lines"),
    plot.margin = unit(c(1, 1, 2, 2), "lines"),
    plot.caption = element_text(face = "italic")
  ) +
  # Annotate only the SNP with the smallest p-value for each chromosome among the associated SNPs
  geom_text_repel(
    data = min_pval_snps,
    aes(label = SNP),
    size = 3,
    nudge_y = 0.01,
    segment.color = NA,
    max.overlaps = Inf # Set to 'Inf' to show all annotations
  )
```

```{r}
# Save the plot
ggsave(
  here(
    "output", "pcadapt", "figures", "man_aut_pcadapt_outflank.pdf"
  ),
  width  = 8,
  height = 5,
  units  = "in"
)
```


We can create windows and count how many highlighted SNPs we have in each window. Then we can focus in genomic areas with several SNPs
```{r, fig.width=8, fig.height=5}
cluster_df <- filtered_df %>%
  mutate(Window_Start = floor(Position / 10000000) * 10000000) %>%
  group_by(Chromosome, Window_Start) %>%
  summarise(SNP_count = n(), .groups = 'drop')

# Create the plot
ggplot(pcadapt_res_df, aes(x = Position, y = -log10(pvalues))) +
  geom_point(
    aes(color = Chromosome),
    data = subset(pcadapt_res_df, highlight == FALSE),
    size = .3
  ) +
  geom_point(
    color = "magenta",
    data = subset(filtered_df, highlight == TRUE),
    size = .3
  ) +
  geom_vline(
    data = cluster_df,
    aes(xintercept = Window_Start + 5000000),
    color = "lightgray",
    linetype = "dashed",
    linewidth = 0.5
  ) +
  geom_text_repel(
    data = cluster_df,
    aes(x = Window_Start + 5000000, y = 15, label = SNP_count),
    vjust = -1,
    hjust = -0.5
  ) +
  scale_color_manual(values = color_vector, guide = "none") +
  labs(x = "Position", y = "-log10(p-value)", caption = "SNPs highlighted in magenta are significant after \n Benjamini-Hochberg adjustment (p<0.001) with pcadapt, \nand were identified as outliers with outFlank \n Gray bars represent 10Mb windows and \n the number of SNPs per window is annotated in black.") +
  facet_wrap( ~ Chromosome, scales = "free_x") +
  scale_x_continuous(labels = k_format) +
  my_theme() +
  theme(
    panel.spacing = unit(.2, "lines"),
    plot.margin = unit(c(1, 1, 2, 2), "lines"),
    plot.caption = element_text(face = "italic"),
    legend.position = "none" # Remove legend
  ) +
  geom_text_repel(
    data = min_pval_snps,
    aes(label = SNP),
    size = 3,
    nudge_y = 0.01,
    segment.color = NA,
    max.overlaps = Inf # Set to 'Inf' to show all annotations
  )


```

Check the SNP ids for each cluster
```{r}
# Create a new dataframe to capture SNPs within each 100kb window for each chromosome
cluster_snps_df <- filtered_df %>%
  mutate(Window_Start = floor(Position / 10000000) * 10000000) %>%
  group_by(Chromosome, Window_Start) %>%
  summarise(SNPs = list(SNP), .groups = 'drop')

# Unnest the SNPs column to show each SNP on its own row
unnested_cluster_snps_df <- cluster_snps_df %>% 
  unnest(SNPs)

# View the unnested data
head(unnested_cluster_snps_df)
```

```{r}
# Convert the list column to a string column
cluster_snps_df_str <- cluster_snps_df %>%
  mutate(SNPs = sapply(SNPs, function(x) paste(x, collapse = ", ")))

# Create the flextable
my_flextable <- flextable(cluster_snps_df_str, cwidth = 2.75)

my_flextable <- autofit(my_flextable)

# Display the flextable
my_flextable

# Initialize a Word document
doc <- read_docx()

# Add flextable to Word document
doc <- body_add_flextable(doc, value = my_flextable)

# Save the Word document
print(doc, target = here("output", "pcadapt", "man_aut_snps_pcadap_outflank.docx"))
```


## 4. pcadapt with all 2 populations (NEW and AUT)

pcadapt performs principal component analysis and computes p-values to test for outliers. The test for outliers is based on the correlations between genetic variation and the first K principal components. pcadapt also handles Pool-seq data for which the statistical analysis is performed on the genetic markers frequencies. Returns an object of class pcadapt.

Clean env and memory
```{r}
# Remove all objects from the environment
rm(list = ls())

# Run the garbage collector to free up memory
gc()
```


```{r}
# read the file
x <- read.pcadapt(here("output", "outflank","new_aut.bed"), type = "bed")
```


```{r, warning=FALSE}
# Run pcadapt with a large number of PCs
pcadapt_res <- pcadapt(x, K = 30)

# Create a scree plot
plot(pcadapt_res, option = "screeplot")
```

Choose PCs
```{r}
# perform the analysis
pcadapt_res <- pcadapt(
  x, 
  method = c("mahalanobis"),
  min.maf = 0.1,
  LD.clumping = NULL,
  tol = 1e-04,
  K = 2) # choose the right K for your data

str(pcadapt_res)
```



```{r}
#   ____________________________________________________________________________
#   import the bim file with the SNP data                                   ####
snps <-
  read_delim(                    # to learn about the options use here, run ?read_delim on the console.
    here(
      "output", "outflank", "new_aut.bim"
    ),                           # use library here to load it
    col_names      = FALSE,      # we don't have header in the input file
    show_col_types = FALSE,      # suppress message from read_delim
    col_types      = "ccidcc"    # set the class of each column
  )
#
# set column names
colnames(
  snps
) <-                             # to add a header in our tibble
  c(
    "Scaffold", "SNP", "Cm", "Position", "Allele1", "Allele2"
  )
#
# check the tibble
head(snps)
```

```{r}
# Combine into a data frame
pcadapt_res_df <- data.frame(
  SNP = snps$SNP,
  Chromosome = snps$Scaffold,
  Position = snps$Position,
  pvalues = pcadapt_res$pvalues,
  stat = pcadapt_res$stat
) |> drop_na()
head(pcadapt_res_df)
```


Adjust
```{r}
# Adjust the p-values using Benjamini-Hochberg method
padj <- p.adjust(pcadapt_res_df$pvalues,method="BH")

# Define significance level
alpha <- 0.05

# Get indices of significant SNPs
outliers_indices <- which(padj < alpha)

# Get the SNP IDs of the outliers
outlier_snps <- pcadapt_res_df$SNP[outliers_indices]

# Print the SNP IDs
length(outlier_snps)

# Save it
write.table(
  outlier_snps,
  file = here("output", "pcadapt","new_aut_SNPs_pcadapt.txt"),
  row.names = FALSE,
  quote = FALSE,
  col.names = FALSE,
  sep = "\n"
)
```


```{r}
# Set colors for the chromosomes
color_vector <- c("#CCF6D6", "#F6E1CC", "#CCD8F6")  # Add or remove colors as needed.
names(color_vector) <- unique(pcadapt_res_df$Chromosome)  # Make sure unique(df_sub$Chromosome) gives all unique Chromosome values.

# Adjust the p-values using Benjamini-Hochberg method
padj <- p.adjust(pcadapt_res_df$pvalues,method="BH")

# Define significance level
alpha <- 0.05

# Get indices of significant SNPs
outliers_indices <- which(padj < alpha)

# Create a new 'highlight' column, initially set to FALSE
pcadapt_res_df$highlight <- FALSE

# Update the 'highlight' column to highlight these outlier SNPs
pcadapt_res_df$highlight[outliers_indices] <- TRUE

# Identify the SNP with the smallest p-value in each chromosome among the associated SNPs
min_pval_snps <- pcadapt_res_df |>
  filter(highlight) |>
  group_by(Chromosome) |>
  slice(which.min(pvalues))

# Custom label function
k_format <- function(x) {
  paste0(format(x / 1e6, big.mark = "", scientific = FALSE), "k")
}

# source the plotting function
source(
  here(
    "scripts", "analysis", "my_theme2.R"
  )
)

# Create the plot
ggplot(pcadapt_res_df, aes(x = Position, y = -log10(pvalues))) +
  geom_point(aes(color = Chromosome),
             data = subset(pcadapt_res_df, highlight == FALSE),
             size = .5) +
  geom_point(
    color = "magenta",
    data = subset(pcadapt_res_df, highlight == TRUE),
    size = .5
  ) +
  scale_color_manual(values = color_vector, guide = "none") +
  labs(title = "pcadapt Brazil", x = "Position", y = "-log10(p-value)", caption = "SNPs highlighted in magenta are significant after Benjamini-Hochberg adjustment (p<0.05).") +
  facet_wrap(~ Chromosome, scales = "free_x") +
  scale_x_continuous(labels = k_format) +
  my_theme() +
  theme(panel.spacing = unit(.2, "lines"),
        plot.margin = unit(c(1, 1, 2, 2), "lines"),
        plot.caption = element_markdown(face = "italic", color = "#574E4E")) +
  # Annotate only the SNP with the smallest p-value for each chromosome among the associated SNPs
  geom_text_repel(
    data = min_pval_snps,
    aes(label = SNP),
    size = 3,
    nudge_y = 0.01,
    segment.color = NA,
    max.overlaps = Inf # Set to 'Inf' to show all annotations
  )

# Save the plot
ggsave(
  here(
    "output", "pcadapt", "figures", "new_aut_pcadapt.pdf"
  ),
  width  = 8,
  height = 5,
  units  = "in"
)
```

```{r}
plot(pcadapt_res, option = "qqplot")
```


```{r}
plot(pcadapt_res, option = "scores")
```

```{r}
hist(pcadapt_res$pvalues, xlab = "p-values", main = NULL, breaks = 50, col = "pink")
```


```{r, warning=FALSE}
plot(pcadapt_res, option = "stat.distribution")
```

Choosing a cutoff for outlier detection

q-values
```{r}
qval <- qvalue(pcadapt_res$pvalues)$qvalues
alpha <- 0.05
outliers <- which(qval < alpha)
length(outliers)
```

Benjamini-Hochberg Procedure
```{r}
padj <- p.adjust(pcadapt_res$pvalues,method="BH")
alpha <- 0.05
outliers <- which(padj < alpha)
length(outliers)
```

Bonferroni correction

```{r}
padj <- p.adjust(pcadapt_res$pvalues,method="bonferroni")
alpha <- 0.05
outliers <- which(padj < alpha)
length(outliers)
```

Loadings

```{r}
par(mfrow = c(2, 2))
for (i in 1:2)
  plot(pcadapt_res$loadings[, i], pch = 19, cex = .3, ylab = paste0("Loadings PC", i))
```


### 4.1 Venn diagram outFlank vs pcadapt

```{r}
# Read data from txt files
outflank_snps <-
  read.table(
    here("output", "outflank", "new_aut_SNPs_outFlank.txt"),
    stringsAsFactors = FALSE
  ) |>
  drop_na()

pcadapt_snps <-
  read.table(
    here("output", "pcadapt", "new_aut_SNPs_pcadapt.txt"),
    stringsAsFactors = FALSE
  )

# Create a list with all dataframes
list_of_clusters <- list("outFlank" = outflank_snps$V1, "pcadapt" = pcadapt_snps$V1)


# Create Venn diagram
venn_diagram <- ggvenn(list_of_clusters, fill_color = c("steelblue", "darkorange"))
print(venn_diagram)

# Find common SNPs
common_SNPs <- Reduce(intersect, list_of_clusters)

# Save the shared SNP ids into a txt file
write.table(
  common_SNPs,
  file = here("output", "pcadapt", "new_aut_common_SNPs_pcadapt_outflank.txt"),
  row.names = FALSE,
  col.names = FALSE,
  quote = FALSE
)

# # Save Venn diagram to PDF
output_path <- here("output", "pcadapt", "figures", "new_aut_significant_snps.pdf")
ggsave(output_path, venn_diagram, height = 5, width = 5, dpi = 300)
```

With python

Clean env
```{r}
py_run_string("import gc; gc.collect()")
```

Venn
```{python}
import pandas as pd
from matplotlib_venn import venn2
import matplotlib.pyplot as plt

# File paths
path_outflank = 'output/outflank/new_aut_SNPs_outFlank.txt'
path_pcadapt = 'output/pcadapt/new_aut_SNPs_pcadapt.txt'
pdf_output_path = 'output/pcadapt/venn_NEW_AUT_pcadapt_outflank.pdf'  # PDF output file path

# Read the data (assuming the SNP IDs are in the first column)
outflank_snps = pd.read_csv(path_outflank, sep="\t", header=None)
pcadapt_snps = pd.read_csv(path_pcadapt, sep="\t", header=None)

# Drop NA values if any
outflank_snps.dropna(inplace=True)
pcadapt_snps.dropna(inplace=True)

# Create sets from the first column of each dataframe
set_outflank = set(outflank_snps[0])
set_pcadapt = set(pcadapt_snps[0])

# Create a Venn diagram
venn2([set_outflank, set_pcadapt], ('outFlank', 'pcadapt'), set_colors=('green', 'gray'))

# Save the plot in PDF format
plt.savefig(pdf_output_path, format='pdf')

# Show the plot
plt.show()

# Clearing the environment
del path_outflank, path_pcadapt, pdf_output_path, outflank_snps, pcadapt_snps, set_outflank, set_pcadapt
plt.clf()  # Clear the current figure
plt.cla()  # Clear the current axes

# Garbage collection
gc.collect()
```


Create plot with the shared SNPs
```{r, fig.width=8, fig.height=5}
# Filter the dataframe
filtered_df <- pcadapt_res_df |> filter(SNP %in% common_SNPs)

# Create the plot
ggplot(pcadapt_res_df, aes(x = Position, y = -log10(pvalues))) +
  geom_point(
    aes(color = Chromosome),
    data = subset(pcadapt_res_df, highlight == FALSE),
    size = .3
  ) +
  geom_point(
    color = "magenta",
    data = subset(filtered_df, highlight == TRUE),
    size = .3
  ) +
  scale_color_manual(values = color_vector, guide = "none") +
  labs(x = "Position", y = "-log10(p-value)", caption = "SNPs highlighted in magenta are significant after \n Benjamini-Hochberg adjustment (p<0.001) with pcadapt, \nand were identified as outliers with outFlank") +
  facet_wrap( ~ Chromosome, scales = "free_x") +
  scale_x_continuous(labels = k_format) +
  my_theme() +
  theme(
    panel.spacing = unit(.2, "lines"),
    plot.margin = unit(c(1, 1, 2, 2), "lines"),
    plot.caption = element_text(face = "italic")
  ) +
  # Annotate only the SNP with the smallest p-value for each chromosome among the associated SNPs
  geom_text_repel(
    data = min_pval_snps,
    aes(label = SNP),
    size = 3,
    nudge_y = 0.01,
    segment.color = NA,
    max.overlaps = Inf # Set to 'Inf' to show all annotations
  )
```

```{r}
# Save the plot
ggsave(
  here(
    "output", "pcadapt", "figures", "new_aut_pcadapt_outflank.pdf"
  ),
  width  = 8,
  height = 5,
  units  = "in"
)
```


We can create windows and count how many highlighted SNPs we have in each window. Then we can focus in genomic areas with several SNPs
```{r, fig.width=8, fig.height=5}
cluster_df <- filtered_df %>%
  mutate(Window_Start = floor(Position / 10000000) * 10000000) %>%
  group_by(Chromosome, Window_Start) %>%
  summarise(SNP_count = n(), .groups = 'drop')

# Create the plot
ggplot(pcadapt_res_df, aes(x = Position, y = -log10(pvalues))) +
  geom_point(
    aes(color = Chromosome),
    data = subset(pcadapt_res_df, highlight == FALSE),
    size = .3
  ) +
  geom_point(
    color = "magenta",
    data = subset(filtered_df, highlight == TRUE),
    size = .3
  ) +
  geom_vline(
    data = cluster_df,
    aes(xintercept = Window_Start + 5000000),
    color = "lightgray",
    linetype = "dashed",
    linewidth = 0.5
  ) +
  geom_text_repel(
    data = cluster_df,
    aes(x = Window_Start + 5000000, y = 15, label = SNP_count),
    vjust = -1,
    hjust = -0.5
  ) +
  scale_color_manual(values = color_vector, guide = "none") +
  labs(x = "Position", y = "-log10(p-value)", caption = "SNPs highlighted in magenta are significant after \n Benjamini-Hochberg adjustment (p<0.001) with pcadapt, \nand were identified as outliers with outFlank \n Gray bars represent 10Mb windows and \n the number of SNPs per window is annotated in black.") +
  facet_wrap( ~ Chromosome, scales = "free_x") +
  scale_x_continuous(labels = k_format) +
  my_theme() +
  theme(
    panel.spacing = unit(.2, "lines"),
    plot.margin = unit(c(1, 1, 2, 2), "lines"),
    plot.caption = element_text(face = "italic"),
    legend.position = "none" # Remove legend
  ) +
  geom_text_repel(
    data = min_pval_snps,
    aes(label = SNP),
    size = 3,
    nudge_y = 0.01,
    segment.color = NA,
    max.overlaps = Inf # Set to 'Inf' to show all annotations
  )


```

Check the SNP ids for each cluster
```{r}
# Create a new dataframe to capture SNPs within each 100kb window for each chromosome
cluster_snps_df <- filtered_df %>%
  mutate(Window_Start = floor(Position / 10000000) * 10000000) %>%
  group_by(Chromosome, Window_Start) %>%
  summarise(SNPs = list(SNP), .groups = 'drop')

# Unnest the SNPs column to show each SNP on its own row
unnested_cluster_snps_df <- cluster_snps_df %>% 
  unnest(SNPs)

# View the unnested data
head(unnested_cluster_snps_df)
```

```{r}
# Convert the list column to a string column
cluster_snps_df_str <- cluster_snps_df %>%
  mutate(SNPs = sapply(SNPs, function(x) paste(x, collapse = ", ")))

# Create the flextable
my_flextable <- flextable(cluster_snps_df_str, cwidth = 2.75)

my_flextable <- autofit(my_flextable)

# Display the flextable
my_flextable

# Initialize a Word document
doc <- read_docx()

# Add flextable to Word document
doc <- body_add_flextable(doc, value = my_flextable)

# Save the Word document
print(doc, target = here("output", "pcadapt", "new_aut_snps_pcadap_outflank.docx"))
```










## 5. pcadapt with all 2 populations (NEW and MAN)

pcadapt performs principal component analysis and computes p-values to test for outliers. The test for outliers is based on the correlations between genetic variation and the first K principal components. pcadapt also handles Pool-seq data for which the statistical analysis is performed on the genetic markers frequencies. Returns an object of class pcadapt.

Clean env and memory
```{r}
# Remove all objects from the environment
rm(list = ls())

# Run the garbage collector to free up memory
gc()
```


```{r}
# read the file
x <- read.pcadapt(here("output", "outflank","man_new.bed"), type = "bed")
```


```{r, warning=FALSE}
# Run pcadapt with a large number of PCs
pcadapt_res <- pcadapt(x, K = 30)

# Create a scree plot
plot(pcadapt_res, option = "screeplot")
```

Choose PCs
```{r}
# perform the analysis
pcadapt_res <- pcadapt(
  x, 
  method = c("mahalanobis"),
  min.maf = 0.1,
  LD.clumping = NULL,
  tol = 1e-04,
  K = 3) # choose the right K for your data

str(pcadapt_res)
```



```{r}
#   ____________________________________________________________________________
#   import the bim file with the SNP data                                   ####
snps <-
  read_delim(                    # to learn about the options use here, run ?read_delim on the console.
    here(
      "output", "outflank", "man_new.bim"
    ),                           # use library here to load it
    col_names      = FALSE,      # we don't have header in the input file
    show_col_types = FALSE,      # suppress message from read_delim
    col_types      = "ccidcc"    # set the class of each column
  )
#
# set column names
colnames(
  snps
) <-                             # to add a header in our tibble
  c(
    "Scaffold", "SNP", "Cm", "Position", "Allele1", "Allele2"
  )
#
# check the tibble
head(snps)
```

```{r}
# Combine into a data frame
pcadapt_res_df <- data.frame(
  SNP = snps$SNP,
  Chromosome = snps$Scaffold,
  Position = snps$Position,
  pvalues = pcadapt_res$pvalues,
  stat = pcadapt_res$stat
) |> drop_na()
head(pcadapt_res_df)
```


Adjust
```{r}
# Adjust the p-values using Benjamini-Hochberg method
padj <- p.adjust(pcadapt_res_df$pvalues,method="BH")

# Define significance level
alpha <- 0.05

# Get indices of significant SNPs
outliers_indices <- which(padj < alpha)

# Get the SNP IDs of the outliers
outlier_snps <- pcadapt_res_df$SNP[outliers_indices]

# Print the SNP IDs
length(outlier_snps)

# Save it
write.table(
  outlier_snps,
  file = here("output", "pcadapt","man_new_SNPs_pcadapt.txt"),
  row.names = FALSE,
  quote = FALSE,
  col.names = FALSE,
  sep = "\n"
)
```


```{r}
# Set colors for the chromosomes
color_vector <- c("#CCF6D6", "#F6E1CC", "#CCD8F6")  # Add or remove colors as needed.
names(color_vector) <- unique(pcadapt_res_df$Chromosome)  # Make sure unique(df_sub$Chromosome) gives all unique Chromosome values.

# Adjust the p-values using Benjamini-Hochberg method
padj <- p.adjust(pcadapt_res_df$pvalues,method="BH")

# Define significance level
alpha <- 0.05

# Get indices of significant SNPs
outliers_indices <- which(padj < alpha)

# Create a new 'highlight' column, initially set to FALSE
pcadapt_res_df$highlight <- FALSE

# Update the 'highlight' column to highlight these outlier SNPs
pcadapt_res_df$highlight[outliers_indices] <- TRUE

# Identify the SNP with the smallest p-value in each chromosome among the associated SNPs
min_pval_snps <- pcadapt_res_df |>
  filter(highlight) |>
  group_by(Chromosome) |>
  slice(which.min(pvalues))

# Custom label function
k_format <- function(x) {
  paste0(format(x / 1e6, big.mark = "", scientific = FALSE), "k")
}

# source the plotting function
source(
  here(
    "scripts", "analysis", "my_theme2.R"
  )
)

# Create the plot
ggplot(pcadapt_res_df, aes(x = Position, y = -log10(pvalues))) +
  geom_point(aes(color = Chromosome),
             data = subset(pcadapt_res_df, highlight == FALSE),
             size = .5) +
  geom_point(
    color = "magenta",
    data = subset(pcadapt_res_df, highlight == TRUE),
    size = .5
  ) +
  scale_color_manual(values = color_vector, guide = "none") +
  labs(title = "pcadapt Brazil", x = "Position", y = "-log10(p-value)", caption = "SNPs highlighted in magenta are significant after Benjamini-Hochberg adjustment (p<0.05).") +
  facet_wrap(~ Chromosome, scales = "free_x") +
  scale_x_continuous(labels = k_format) +
  my_theme() +
  theme(panel.spacing = unit(.2, "lines"),
        plot.margin = unit(c(1, 1, 2, 2), "lines"),
        plot.caption = element_markdown(face = "italic", color = "#574E4E")) +
  # Annotate only the SNP with the smallest p-value for each chromosome among the associated SNPs
  geom_text_repel(
    data = min_pval_snps,
    aes(label = SNP),
    size = 3,
    nudge_y = 0.01,
    segment.color = NA,
    max.overlaps = Inf # Set to 'Inf' to show all annotations
  )

# Save the plot
ggsave(
  here(
    "output", "pcadapt", "figures", "man_new_pcadapt.pdf"
  ),
  width  = 8,
  height = 5,
  units  = "in"
)
```

```{r}
plot(pcadapt_res, option = "qqplot")
```


```{r}
plot(pcadapt_res, option = "scores")
```

```{r}
hist(pcadapt_res$pvalues, xlab = "p-values", main = NULL, breaks = 50, col = "pink")
```


```{r, warning=FALSE}
plot(pcadapt_res, option = "stat.distribution")
```

Choosing a cutoff for outlier detection

q-values
```{r}
qval <- qvalue(pcadapt_res$pvalues)$qvalues
alpha <- 0.05
outliers <- which(qval < alpha)
length(outliers)
```

Benjamini-Hochberg Procedure
```{r}
padj <- p.adjust(pcadapt_res$pvalues,method="BH")
alpha <- 0.05
outliers <- which(padj < alpha)
length(outliers)
```

Bonferroni correction

```{r}
padj <- p.adjust(pcadapt_res$pvalues,method="bonferroni")
alpha <- 0.05
outliers <- which(padj < alpha)
length(outliers)
```

Loadings

```{r}
par(mfrow = c(2, 2))
for (i in 1:2)
  plot(pcadapt_res$loadings[, i], pch = 19, cex = .3, ylab = paste0("Loadings PC", i))
```


### 5.1 Venn diagram outFlank vs pcadapt

We can make a venn diagram because outFlank did not identify any outlier.

## 6. Venn diagram
```{r, fig.width=8, fig.height=8}
# Read data from txt files
NEW_MAN_AUT <-
  read.table(
    here("output", "pcadapt", "common_SNPs_pcadapt_outflank.txt"),
    stringsAsFactors = FALSE
  ) |>
  drop_na()

MAN_AUT <-
  read.table(
    here("output", "pcadapt", "man_aut_common_SNPs_pcadapt_outflank.txt"),
    stringsAsFactors = FALSE
  )


NEW_AUT <-
  read.table(
    here("output", "pcadapt", "new_aut_common_SNPs_pcadapt_outflank.txt"),
    stringsAsFactors = FALSE
  )


NEW_MAN <-
  read.table(
    here("output", "pcadapt", "man_new_SNPs_pcadapt.txt"),
    stringsAsFactors = FALSE
  )

# Create a list with all dataframes
list_of_clusters <- list("NEW_MAN_AUT" = NEW_MAN_AUT$V1, "MAN_AUT" = MAN_AUT$V1, "NEW_AUT" = NEW_AUT$V1, "NEW_MAN" = NEW_MAN$V1)


# Create Venn diagram
venn_diagram <- ggvenn(list_of_clusters)

# Increase plot margins
venn_diagram <- venn_diagram + theme(plot.margin = margin(60, 60, 60, 60, "points"))

# Resize text
venn_diagram <- venn_diagram + theme(text = element_text(size = 5))


# Print the adjusted plot
print(venn_diagram)

# Find the intersect of NEW_MAN_AUT, MAN_AUT, and NEW_AUT
common_elements <- Reduce(intersect, list(NEW_MAN_AUT$V1, MAN_AUT$V1, NEW_AUT$V1))


# # Save the shared SNP ids into a txt file
write.table(
  common_elements,
  file = here("output", "pcadapt", "4_way_venn_common_SNPs_pcadapt_outflank.txt"),
  row.names = FALSE,
  col.names = FALSE,
  quote = FALSE
)

# # Save Venn diagram to PDF
output_path <- here("output", "pcadapt", "figures", "4_way_venn_significant_snps.pdf")
ggsave(output_path, venn_diagram, height = 8, width = 8, dpi = 300)
```

With python
Create plot with the shared SNPs
```{r, fig.width=8, fig.height=5}
# Filter the dataframe
filtered_df <- pcadapt_res_df |> 
  filter(SNP %in% common_elements)

# Create the plot
ggplot(pcadapt_res_df, aes(x = Position, y = -log10(pvalues))) +
  geom_point(
    aes(color = Chromosome),
    data = subset(pcadapt_res_df, highlight == FALSE),
    size = .3
  ) +
  geom_point(
    color = "magenta",
    data = subset(filtered_df, highlight == TRUE),
    size = .3
  ) +
  scale_color_manual(values = color_vector, guide = "none") +
  labs(x = "Position", y = "-log10(p-value)") +
  facet_wrap( ~ Chromosome, scales = "free_x") +
  scale_x_continuous(labels = k_format) +
  my_theme() +
  theme(
    panel.spacing = unit(.2, "lines"),
    plot.margin = unit(c(1, 1, 2, 2), "lines"),
    plot.caption = element_text(face = "italic")
  )
```

We can create windows and count how many highlighted SNPs we have in each window. Then we can focus in genomic areas with several SNPs
```{r, fig.width=8, fig.height=5}
cluster_df <- filtered_df %>%
  mutate(Window_Start = floor(Position / 10000000) * 10000000) %>%
  group_by(Chromosome, Window_Start) %>%
  summarise(SNP_count = n(), .groups = 'drop')

# Create the plot
ggplot(pcadapt_res_df, aes(x = Position, y = -log10(pvalues))) +
  geom_point(
    aes(color = Chromosome),
    data = subset(pcadapt_res_df, highlight == FALSE),
    size = .3
  ) +
  geom_point(
    color = "magenta",
    data = subset(filtered_df, highlight == TRUE),
    size = .3
  ) +
  geom_vline(
    data = cluster_df,
    aes(xintercept = Window_Start + 5000000),
    color = "lightgray",
    linetype = "dashed",
    linewidth = 0.5
  ) +
  geom_text_repel(
    data = cluster_df,
    aes(x = Window_Start + 5000000, y = 10, label = SNP_count),
    vjust = -1,
    hjust = -0.5
  ) +
  scale_color_manual(values = color_vector, guide = "none") +
  labs(x = "Position", y = "-log10(p-value)", caption = "SNPs highlighted in magenta are significant after \n Benjamini-Hochberg adjustment (p<0.001) with pcadapt, \nand were identified as outliers with outFlank \n Gray bars represent 10Mb windows and \n the number of SNPs per window is annotated in black.") +
  facet_wrap( ~ Chromosome, scales = "free_x") +
  scale_x_continuous(labels = k_format) +
  my_theme() +
  theme(
    panel.spacing = unit(.2, "lines"),
    plot.margin = unit(c(1, 1, 2, 2), "lines"),
    plot.caption = element_text(face = "italic"),
    legend.position = "none" # Remove legend
  ) 

# # Save Venn diagram to PDF
output_path <- here("output", "pcadapt", "figures", "manhattan_from_4_way_venn_snps.pdf")
ggsave(output_path, height = 5, width = 8, dpi = 300)
```

Check the SNP ids for each cluster
```{r}
# Create a new dataframe to capture SNPs within each 100kb window for each chromosome
cluster_snps_df <- filtered_df %>%
  mutate(Window_Start = floor(Position / 10000000) * 10000000) %>%
  group_by(Chromosome, Window_Start) %>%
  summarise(SNPs = list(SNP), .groups = 'drop')

# Unnest the SNPs column to show each SNP on its own row
unnested_cluster_snps_df <- cluster_snps_df %>% 
  unnest(SNPs)

# View the unnested data
head(unnested_cluster_snps_df)
```

```{r}
# Convert the list column to a string column
cluster_snps_df_str <- cluster_snps_df %>%
  mutate(SNPs = sapply(SNPs, function(x) paste(x, collapse = ", ")))

# Create the flextable
my_flextable <- flextable(cluster_snps_df_str, cwidth = 2.75)

my_flextable <- autofit(my_flextable)

# Display the flextable
my_flextable

# Initialize a Word document
doc <- read_docx()

# Add flextable to Word document
doc <- body_add_flextable(doc, value = my_flextable)

# Save the Word document
print(doc, target = here("output", "pcadapt", "4_way_venn_pcadap_outflank.docx"))
```


We can also highlight all the 158 SNPs from the selection scans

```{r}
# Combine all three data frames into one
combined_df <- bind_rows(MAN_AUT, NEW_AUT, NEW_MAN_AUT)

# Count unique values and add a 'Count' column
result <- combined_df %>%
  group_by(V1) %>%
  summarise(Count = n()) %>%
  arrange(V1) |>
  dplyr::rename(SNP = V1)

# Show the result
head(result)
```
Create plot with the shared SNPs
```{r, fig.width=8, fig.height=5}
# Filter the dataframe
filtered_df <- pcadapt_res_df |> 
  filter(SNP %in% result$SNP)

# Create the plot
ggplot(pcadapt_res_df, aes(x = Position, y = -log10(pvalues))) +
  geom_point(
    aes(color = Chromosome),
    data = subset(pcadapt_res_df, highlight == FALSE),
    size = .3
  ) +
  geom_point(
    color = "magenta",
    data = subset(filtered_df, highlight == TRUE),
    size = .3
  ) +
  scale_color_manual(values = color_vector, guide = "none") +
  labs(x = "Position", y = "-log10(p-value)") +
  facet_wrap( ~ Chromosome, scales = "free_x") +
  scale_x_continuous(labels = k_format) +
  my_theme() +
  theme(
    panel.spacing = unit(.2, "lines"),
    plot.margin = unit(c(1, 1, 2, 2), "lines"),
    plot.caption = element_text(face = "italic")
  )
```

We can create windows and count how many highlighted SNPs we have in each window. Then we can focus in genomic areas with several SNPs
```{r, fig.width=8, fig.height=5}
cluster_df <- filtered_df |>
  mutate(Window_Start = floor(Position / 10000000) * 10000000) |>
  group_by(Chromosome, Window_Start) |>
  summarise(SNP_count = n(), .groups = 'drop') |>
  dplyr::filter(SNP_count >= 3) # plot lines for windows with 3 or more SNPs

# Create the plot
ggplot(pcadapt_res_df, aes(x = Position, y = -log10(pvalues))) +
  geom_point(
    aes(color = Chromosome),
    data = subset(pcadapt_res_df, highlight == FALSE),
    size = .3
  ) +
  geom_point(
    color = "magenta",
    data = subset(filtered_df, highlight == TRUE),
    size = .3
  ) +
  geom_vline(
    data = cluster_df,
    aes(xintercept = Window_Start + 5000000),
    color = "lightgray",
    linetype = "dashed",
    linewidth = 0.5
  ) +
  geom_text_repel(
    data = cluster_df,
    aes(x = Window_Start + 5000000, y = 10, label = SNP_count),
    vjust = -1,
    hjust = -0.5
  ) +
  scale_color_manual(values = color_vector, guide = "none") +
  labs(x = "Position", y = "-log10(p-value)", caption = "SNPs highlighted in magenta are significant after \n Benjamini-Hochberg adjustment (p<0.001) with pcadapt, \nand were identified as outliers with outFlank \n Gray bars represent 10Mb windows and \n the number of SNPs per window is annotated in black.") +
  facet_wrap( ~ Chromosome, scales = "free_x") +
  scale_x_continuous(labels = k_format) +
  my_theme() +
  theme(
    panel.spacing = unit(.2, "lines"),
    plot.margin = unit(c(1, 1, 2, 2), "lines"),
    plot.caption = element_text(face = "italic"),
    legend.position = "none" # Remove legend
  ) 

# # Save Venn diagram to PDF
output_path <- here("output", "pcadapt", "figures", "manhattan_from_4_way_venn_158_snps.pdf")
ggsave(output_path, height = 5, width = 8, dpi = 300)
```


Check the SNP ids for each cluster
```{r}
# Create a new dataframe to capture SNPs within each 100kb window for each chromosome
cluster_snps_df <- filtered_df %>%
  mutate(Window_Start = floor(Position / 10000000) * 10000000) %>%
  group_by(Chromosome, Window_Start) %>%
  summarise(SNPs = list(SNP), .groups = 'drop')

# Unnest the SNPs column to show each SNP on its own row
unnested_cluster_snps_df <- cluster_snps_df %>% 
  unnest(SNPs)

# View the unnested data
head(unnested_cluster_snps_df)
```

```{r}
# Convert the list column to a string column
cluster_snps_df_str <- cluster_snps_df %>%
  mutate(SNPs = sapply(SNPs, function(x) paste(x, collapse = ", ")))

# Create the flextable
my_flextable <- flextable(cluster_snps_df_str, cwidth = 2.75)

my_flextable <- autofit(my_flextable)

# Display the flextable
my_flextable

# Initialize a Word document
doc <- read_docx()

# Add flextable to Word document
doc <- body_add_flextable(doc, value = my_flextable)

# Save the Word document
print(doc, target = here("output", "pcadapt", "4_way_venn_pcadap_outflank_158_SNPs.docx"))
```